function [outputS, outputIT, outputGau,mean_S_gau, pre_stim_means, post_stim_means] = SpikePETH(cfg_in, S,t,varargin)
%% SpikePETH: computes the perievent histogram for spike data "S" at events
%             "t".  Outputs
%
%
%
%          Inputs:
%           - cfg_in [struct]: contains configuration paramters
%           - S      [TS]      Spike timestamp data
%           - t      [n x T]   timestamps for events
%          Outputs:
%           -
%           -
%           -
% based on spikePETH by MvdM
% modified by EC to match mvdmlab codebase- 2017-05-01

%% set defaults
cfg_def.shuff = []; % give a value for shuffle. will skip if empty
cfg_def.window = [-2 5];
cfg_def.dt = 0.001;
cfg_def.excessBounds = 1;
cfg_def.outputGrid = 0;
cfg_def.evt_color_mat = repmat([0 0 0], length(t),1); 
cfg_def.rec_color = [4,172,218]./255;
cfg_def.linewidth = 2;
cfg_def.color = [0.3639    0.5755    0.7484];
cfg_def.binsize = cfg_def.dt; % used for gaussian kernal.  select a small bin size for good time resolution
cfg_def.waves = [];
cfg_def.contrast_waves = [];
cfg_def.c_ord = linspecer(4);
cfg_def.gauss_window = 1;
cfg_def.gauss_sd = 0.02; 
cfg_def.plot = 'on'; % turn output 'on' or 'off';
cfg = ProcessConfig2(cfg_def, cfg_in);

cfg.binsize = cfg.dt; 
extract_varargin;

c_ord = linspecer(5); 

%% compute the spike PETH
nT = length(t);

outputS = [];
outputT = [];
outputGau = [];
% outputID = repmat(inf, nT, diff(cfg.window)/cfg.dt+1);
outputIT = linspace(cfg.window(1), cfg.window(2), diff(cfg.window)/cfg.dt+1);

if cfg.outputGrid
    xbin = cfg.window(1):cfg.dt:cfg.window(2);
    outputG = zeros(nT,length(xbin)-1);
end

% set up gau kernal
gauss_window = cfg.gauss_window./cfg.binsize; % 1 second window
gauss_SD = cfg.gauss_sd./cfg.binsize; % 0.02 seconds (20ms) SD
gk = gausskernel(gauss_window,gauss_SD); gk = gk./cfg.binsize; % normalize by binsize

% convolve with gaussian for firing rate

% plot(tbin_centers,S_gau_sdf,'g');

for iT = nT:-1:1
    S0 = restrict(S, t(iT)+cfg.window(1)-cfg.excessBounds, t(iT)+cfg.window(2)+cfg.excessBounds);
    if length(S0.t{1}) > 0
        S0 = restrict(S0, t(iT)+cfg.window(1), t(iT)+cfg.window(2));
        
        outputT = [outputT; repmat(iT, length(S0.t{1}),1)];
        outputS = [outputS; S0.t{1}-t(iT)];
        
        %convolve with gaussian for firing rate.
        tbin_edges = t(iT)+cfg.window(1):cfg.binsize:t(iT)+cfg.window(2);
        tbin_centers = tbin_edges(1:end-1)+cfg.binsize/2;
        spk_count = histc(S0.t{1},tbin_edges);
        spk_count = spk_count(1:end-1);
        

        S_gau_sdf = conv2(spk_count,gk,'same'); % convolve with gaussian window
        if size(S_gau_sdf,1) >1
            S_gau_sdf = S_gau_sdf';
        end
        outputGau(:,iT) = S_gau_sdf';
        
        
        if cfg.outputGrid
            
            temp = histc(S0.t{1}-t(iT),xbin); temp = temp(1:end-1);
            if ~isempty(temp)
                outputG(iT,:) = temp;
            end
            
        end
        
    end
end
%% check if there are any spikes
if isempty(outputT)
    disp('No spikes')
    return
end

%% shuffles

% if ~isempty(cfg.shuff)
%     
%     nT = length(t);
%     
%     outputS_shuf = []; 
%     outputT_shuf = [];
%     outputGau_shuf = [];
%     % outputID = repmat(inf, nT, diff(cfg.window)/cfg.dt+1);
%     outputIT = linspace(cfg.window(1), cfg.window(2), diff(cfg.window)/cfg.dt+1);
%     
%     if cfg.outputGrid
%         xbin = cfg.window(1):cfg.dt:cfg.window(2);
%         outputG = zeros(nT,length(xbin)-1);
%     end
%     
%     % convolve with gaussian for firing rate
%     
%     % plot(tbin_centers,S_gau_sdf,'g');
%     
%     for iT = 1:nT
%         this_shuff = S
%         
%         S0 = restrict(S, t(iT)+cfg.window(1)-cfg.excessBounds, t(iT)+cfg.window(2)+cfg.excessBounds);
%         if length(S0.t{1}) > 0
%             S0 = restrict(S0, t(iT)+cfg.window(1), t(iT)+cfg.window(2));
%             
%             
%             for iShuf = cfg.shuff:-1:1 
%             outputT_shuf = [ repmat(iT, length(S0.t{1}),1); outputT_shuf];
%             outputS_shuf = [ S0.t{1}-t(iT); outputS_shuf];
%             
%             %convolve with gaussian for firing rate.
%             tbin_edges = t(iT)+cfg.window(1):cfg.binsize:t(iT)+cfg.window(2);
%             tbin_centers = tbin_edges(1:end-1)+cfg.binsize/2;
%             spk_count = histc(S0.t{1},tbin_edges);
%             spk_count = spk_count(1:end-1);
%             
%             gauss_window = cfg.gauss_window./cfg.binsize; % 1 second window
%             gauss_SD = cfg.gauss_sd./cfg.binsize; % 0.02 seconds (20ms) SD
%             gk = gausskernel(gauss_window,gauss_SD); gk = gk./cfg.binsize; % normalize by binsize
%             S_gau_sdf = conv2(spk_count,gk,'same'); % convolve with gaussian window
%             if size(S_gau_sdf,1) >1
%                 S_gau_sdf = S_gau_sdf';
%             end
%             outputGau_shuf = [S_gau_sdf ; outputGau_shuf];
%             
%             
%             if cfg.outputGrid
%                 
%                 temp = histc(S0.t{1}-t(iT),xbin); temp = temp(1:end-1);
%                 if ~isempty(temp)
%                     outputG(iT,:) = temp;
%                 end
%                 
%             end
%             
%             end % end shuffles. 
%             
%         end
%     end
% end

%% display
clf
if  strcmp(cfg.plot, 'on')
    
    
    % spike raster
    subplot(2,1,1);
    % 	imagesc(window,[1 nT], outputID);
    % 	colormap(1-0.25*gray);
    	hold on;
        u_val = unique(outputT); 
    for iV = 1:length(u_val)
        this_idx = outputT == u_val(iV);
        if isempty(this_idx)
            continue
        end
        plot(outputS(this_idx), outputT(this_idx)+0.5,'.', 'color', cfg.evt_color_mat(u_val(iV),:), 'MarkerSize', 5)
    end
    
%     plot(outputS, outputT+0.5, '.k', 'MarkerSize', 5);
    xlabel('peri-event (sec)');
    ylabel('Event #');
    ylim([1 nT])
    xlim(cfg.window);
    hold on
    if (size(t,1) > 1) || (size(t,2) > 1)
        rectangle('position', [0 1 0.001  nT], 'facecolor', [cfg.rec_color 0.5], 'edgecolor', [cfg.rec_color 0.5])
    else
        rectangle('position', [0 1 abs(mode(t(:,2)-t(:,1)))  nT], 'facecolor', [cfg.rec_color 0.5], 'edgecolor', [cfg.rec_color 0.5])
    end
    %% add in the wave forms
    if ~isempty(cfg.waves)
        for iV = 1:4
            axes('Position', [(.65+(.05*iV)) .8 0.05 .1])
            plot(cfg.waves.mWV(:,iV), 'color', cfg.c_ord(iV, :))
            set(gca, 'visible', 'off')
        end
    end
    
    %%
    % bar graph
    % subplot(3,2,3);
    % m = histc(outputS, outputIT);
    % bar(outputIT,m/cfg.dt/length(t));
    % % 	x = outputIT;
    % % 	m = nanmean(1./outputID);
    % % 	se =  nanstd(1./outputID)/sqrt(nT+1);
    % % 	plot(x,m,'b',x,m+se,'r:',x,m-se,'r:');
    % set(gca, 'XLim', cfg.window);
    % ylabel('FR (Hz)')
    % xlabel('peri-event (sec)');
    
    % mean frequency line
    subplot(2,1,2);
    mean_S_gau = nanmean(outputGau,2);
%     outputITG= linspace(cfg.window(1), cfg.window(2), diff(cfg.window)/gauss_window+1);

    % se_S_gau = nanstd(outputGau,2)/sqrt(nT+1);
    % plot(outputIT(1:end-1),mean_S_gau, 'b',outputIT(1:end-1),mean_S_gau+se_S_gau, 'b:',outputIT(1:end-1),mean_S_gau-se_S_gau, 'b:' )
    plot(outputIT(1:end-1), mean_S_gau,'color', cfg.color, 'linewidth', cfg.linewidth)
    xlim(cfg.window);
    
    idx = nearest_idx3(0, outputIT(1:end-1));
    
    pre_stim_means = nanmean(outputGau(:,1:idx-1),2);
    post_stim_means = nanmean(outputGau(:,idx:end),2);
    

    if ~(max(mean_S_gau)) ==0
        ylim([0 max(mean_S_gau)])
        if (size(t,1) > 1) || (size(t,2) > 1)
            rectangle('position', [0 1 0.001  max(mean_S_gau)], 'facecolor', [cfg.rec_color 0.5], 'edgecolor', [cfg.rec_color 0.5])
        else
            rectangle('position', [0 1 abs(mode(t(:,2)-t(:,1)))  max(mean_S_gau)], 'facecolor', [cfg.rec_color 0.5], 'edgecolor', [cfg.rec_color 0.5])
        end
    end
    
        % add in pre and post event means
    x_lims = xlim; 
    y_lims = ylim; 
    
    text(x_lims(1), y_lims(2)*.9, ['Pre mean: ' num2str(mean(mean_S_gau(1:idx-1)), 2) '+/-' num2str(std(mean_S_gau(1:idx-1)),2) 'Hz'], 'fontweight', 'bold', 'fontsize', 12, 'color',c_ord(1,:) )
    text(x_lims(1), y_lims(2)*.7, ['Post mean: ' num2str(mean(mean_S_gau(idx:end)), 2)  '+/-' num2str(std(mean_S_gau(idx:end)),2) 'Hz' ], 'fontweight', 'bold', 'fontsize', 12, 'color',c_ord(2,:))
    
end

outputIT = outputIT(1:end-1); 

end
